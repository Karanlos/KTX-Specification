KTX is a format for storing textures for OpenGL and OpenGL ES applications. It
is distinguished by the simplicity of the loader required to instantiate a GL
texture object from the file contents.

===========================================================================
 
    Byte[12]   identifier
    UInt32     endianness
    UInt32     glType
    UInt32     glTypeSize
    UInt32     glFormat
    Uint32     glInternalFormat
    Uint32     glBaseInternalFormat
    UInt32     pixelWidth
    UInt32     pixelHeight
    UInt32     pixelDepth
    UInt32     numberOfArrayElements
    UInt32     numberOfFaces
    UInt32     numberOfMipmapLevels
    UInt32     bytesOfKeyValueData

    for each keyValuePair that fits in bytesOfKeyValueData
        UInt32              keyAndValueByteSize
        Byte                keyAndValue[keyAndValueByteSize]
        Byte                zeroPadding[4-(keyAndValueByteSize%4)]
    end

    for each mipmap_level in numberOfMipmapLevels*
        UInt32 imageSize;   
        for each array_element in numberOfArrayElements*
            for each face in numberOfFaces
                for each z_slice in pixelDepth*
                    for each row or row_of_blocks in pixelHeight*
                        for each pixel or block_of_pixels in pixelWidth
                            Byte data[format-specific-number-of-bytes]**
                        end
                    end
                end
                Byte cubePadding[0-3]
            end
        end
        Byte mipPadding[3 - ((imageSize + 3) % 4)]
    end

    *  Replace with 1 if this field is 0.
    ** Uncompressed texture data matches a GL_UNPACK_ALIGNMENT of 4.

identifier

    The file identifier is a unique set of bytes that will differentiate the 
    file from other types of files. It consists of 12 bytes, as follows:

    Byte[12] FileIdentifier = { 
        0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A 
    }
    This can also be expressed using C-style character definitions as:
    Byte[12] FileIdentifier = { 
        '«', 'K', 'T', 'X', ' ', '1', '1', '»', '\r', '\n', '\x1A', '\n' 
    }
    
    The rationale behind the choice of values in the identifier is based on
    the rationale for the identifier in the PNG specification. This identifier
    both identifies the file as an KTX file and provides for immediate
    detection of common file-transfer problems.

    Byte [0] is chosen as a non-ASCII value to reduce the probability that a 
    text file may be misrecognized as an KTX file. It also catches bad file 
    transfers that clear bit 7. 
    Bytes [1..6] identify the format, and are the ascii values for the string 
    "KTX 11". 
    Byte [7] is for aesthetic balance with byte 1 (they are a matching pair 
    of double-angle quotation marks). 
    Bytes [8..9] form a CR-LF sequence which catches bad file transfers that 
    alter newline sequences. 
    Byte [10] is a control-Z character, which stops file display under MS-DOS, 
    and further reduces the chance that a text file will be falsely recognised. 
    Byte [11] is a final line feed, which checks for the inverse of the CR-LF 
    translation problem. 

endianness

    endianness contains the number 0x04030201 written as a 32 bit integer.  If
    the file is little endian then this is represented as the bytes 0x01 0x02
    0x03 0x04.  If the file is big endian then this is represented as the
    bytes 0x04 0x03 0x02 0x01.  When reading endianness as a 32 bit integer
    produces the value 0x04030201 then the endianness of the file matches the
    the endianness of the program that is reading the file and no conersion is
    necessary.  When reading endianness as a 32 bit integer produces the value
    0x01020304 then the endianness of the file is opposite the endianness of
    the program that is reading the file, and in that case the program reading
    the file must endian convert all header bytes to the endianness of the
    program (i.e. a little endian program must convert from big endian, and a
    big endian program must convert to little endian).

glType
 
    For compressed textures, glType must equal 0. For non-compressed textures, 
    glType specifies the type argument passed to glTexImage*D, usually one of 
    the values from table 3.5 of the OpenGL 3.0 specification (UNSIGNED_BYTE, 
    UNSIGNED_SHORT_5_6_5, etc.)

glTypeSize

    glTypeSize specifies the data type size that should be used when 
    endianness conversion is required for the texture data stored in the 
    file. If glType is not 0, this should be the size in bytes corresponding 
    to glType. For texture data which does not depend on platform endianness, 
    including compressed texture data, glTypeSize must equal 1.

glFormat
 
    For compressed textures, glFormat must equal 0. For non-compressed 
    textures, glFormat specifies the format argument passed to glTexImage*D, 
    usually one of the values from table 3.6 of the OpenGL 3.0 specification 
    (RGB, RGBA, BGRA, etc.)

glInternalFormat

    For compressed textures, glInternalFormat must equal the compressed
    internalformat. For non-compressed textures, glInternalFormat specifies
    the internalformat argument passed to glTexImage*D, usually one of the
    sized internalformats from tables 3.16-3.18 of the OpenGL 3.0
    specification. The sized format should be chosen to match the bit depth of
    the data provided.  The glInternalFormat is used for loading uncompressed
    textures in OpenGL and for loading compressed textures in OpenGL and
    OpenGL ES.  It is not usually used for loading uncompressed textures in
    OpenGL ES as OpenGL ES requires that the internal format be the same value
    as the format.

glBaseInternalFormat

    For both compressed and non-compressed textures, glBaseInternalFormat 
    specifies the base internalformat of the texture,
    usually one of the values from table 3.15 of the OpenGL 3.0 specification 
    (RGB, RGBA, ALPHA, etc.). For non-compressed textures, this value will be
    the same as glFormat and is used as the internalformat when loading into
    OpenGL ES.

pixelWidth, pixelHeight, pixelDepth

    The size of the texture image for level 0, in pixels. No rounding to block
    sizes should be applied for block compressed textures.

    For 1D textures pixelHeight and pixelDepth must be 0.
    For 2D and cube textures pixelDepth must be 0.

numberOfArrayElements
 
    numberOfArrayElements specifies the number of array elements. If the 
    texture is not an array texture, numberOfArrayElements must equal 0.
 
numberOfFaces
 
    numberOfFaces specifies the number of cubemap faces. For cubemaps and 
    cubemap arrays this should be 6. For non cubemaps this should be 1. 
    Cube map faces are stored in the order: +X, -X, +Y, -Y, +Z, -Z.
 
numberOfMipmapLevels
 
    numberOfMipmapLevels must equal 1 for non-mipmapped textures. For 
    mipmapped textures, it equals the number of mipmaps.  Mipmaps are stored 
    in order from largest size to smallest size. The first mipmap level is 
    always level 0. A KTX file does not need to contain a complete mipmap 
    pyramid. If numberOfMipmapLevels equals 0, it indicates that a full 
    mipmap pyramid should be generated from level 0 at load time (this is 
    usually not allowed for compressed formats).
 
bytesOfKeyValueData
 
    An arbitrary number of key/value pairs may follow the header.  This can be
    used to encode any arbitrary data.  The bytesOfKeyValueData field
    indicates the total number of bytes of key/value data including all
    keyAndValueByteSize fields, all keyAndValue fields, and all zeroPadding
    fields.  The file offset of the first imageSize field is located at the
    file offset of the bytesOfKeyValueData field plus the value of the
    bytesOfKeyValueData field.

keyAndValueByteSize
 
    keyAndValueByteSize is the number of bytes of combined key and value data 
    in each key/value pair following the header. This includes the size of 
    the key, the NUL byte terminating the key, and all the bytes of data in 
    the value. It does not include the bytes in zeroPadding (and therefore
    does not include the Nul terminator of value).

keyAndValue
 
    keyAndValue contains 2 separate sections.  First it contains a key encoded
    in UTF8. The key must be terminated by a NUL character (a single 0x00
    byte). Keys that begin with the 3 ascii characters 'KTX' are reserved and
    must not be used except as described by this spec (this version of the KTX
    spec does not define any keys).  Immediately following the NUL character
    that terminates the key is the Value data. The value may consist of any
    arbitrary data bytes. Any byte value is allowed.  It is encouraged that
    the value be a UTF8 string, but this is not required.  If the Value data
    is a string of bytes then the NUL termination should not be included in
    the keyAndValueByteSize byte count.
 
zeroPadding
 
    zeroPadding is between 1 and 4 bytes with the value 0x00. The number of 
    bytes must ensure that the byte following the last byte in zeroPadding is 
    in a file offset that is a multiple of 4. This ensures that every 
    keyAndValueByteSize field, and the first imageSize field, is 4 byte 
    aligned.  There is always at least 1 zero byte following the value, and
    this can be considered the Nul terminator byte of the string.  Note that
    this Nul terminator is not included in the keyAndValueByteSize.

imageSize
 
    For most textures imageSize is the number of bytes of pixel data in the
    current LOD level. This includes all z slices, all faces, all rows (or
    rows of blocks) and all pixels (or blocks) in each row for the mipmap
    level.  It does not include any bytes in padding.

    The exception is non-array cubemap textures (any texture where
    numberOfFaces is nonzero and numberOfArrayElements is 0).  For these
    textures imageSize is the number of bytes in each face of the texture
    for the current LOD level, not including bytes in cubePadding or padding.

cubePadding

    For non-array cubemap textures (any texture where numberOfFaces is nonzero
    and numberOfArrayElements is 0) cubePadding contains between 0 and 3 bytes
    to ensure that the data in each face begins at a file offset that is a
    multiple of 4.  In all other cases cubePadding is empty (0 bytes long).
 
mipPadding
    
    Between 0 and 3 bytes to make sure that all imageSize fields are at a
    file offset that is a multiple of 4.

General comments
 
    The unpack alignment is 4. I.e. uncompressed pixel data is packed
    according to the rules described in the OpenGL 1.5 spec for a
    GL_UNPACK_ALIGNMENTs of 4.
 
An example KTX file:
 
    // HEADER
    0xAB, 0x4B, 0x54, 0x58,  //    first four bytes of Byte[12] identifier
    0x20, 0x31, 0x31, 0xBB,  //    next four bytes of  Byte[12] identifier
    0x0D, 0x0A, 0x1A, 0x0A.  //    final for bytes of  Byte[12] identifier
    0x04, 0x03, 0x02, 0x01,  //    Byte[4] endianess (Big endian in this case)
    0x00, 0x00, 0x00, 0x00,  //    UInt32 glType = 0
    0x00, 0x00, 0x00, 0x01,  //    UInt32 glTypeSize = 1
    0x00, 0x00, 0x00, 0x00,  //    UInt32 glFormat = 0
    0x00, 0x00, 0x8D, 0x64,  //    UInt32 glInternalFormat = GL_ETC1_RGB8_OES
    0x00, 0x00, 0x19, 0x07,  //    UInt32 glBaseInternalFormat = GL_RGB
    0x00, 0x00, 0x00, 0x20,  //    UInt32 pixelWidth = 32
    0x00, 0x00, 0x00, 0x20,  //    UInt32 pixelHeight = 32
    0x00, 0x00, 0x00, 0x00,  //    UInt32 pixelDepth = 0 
    0x00, 0x00, 0x00, 0x00,  //    UInt32 numberOfArrayElements = 0 
    0x00, 0x00, 0x00, 0x01,  //    UInt32 numberOfFaces = 1 
    0x00, 0x00, 0x00, 0x01,  //    UInt32 numberOfMipmapLevels = 1
    0x00, 0x00, 0x00, 0x10,  //    UInt32 bytesOfKeyValueData = 16 
    // METADATA
    0x00, 0x00, 0x00, 0x01,  //    UInt32 keyAndValueByteSize = 8
    0x61, 0x70, 0x69, 0x00,  //    UTF8   key:   'api\0'
    0x6A, 0x6F, 0x6B, 0x65,  //    UTF8   value: 'gles'
    0x00, 0x00, 0x00, 0x00,  //    Byte[4]   zeroPadding (4 bytes)
    // TEXTURE DATA
    0x00, 0x00, 0x02, 0x00,  //    UInt32 imageSize = 512 bytes 
    0xD8, 0xD8, 0xD8, 0xDA,  //    Byte[512] ETC compressed texture data...
    ... 
===========================================================================
