<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>KTX File Format</title>
    <link rel="stylesheet" type="text/css" href="Khronos-WD.css" />
    <link rel="stylesheet" type="text/css" href="default.css" />
    <script src="jquery-1.3.2.min.js" type="text/javascript"></script>

    <script src="generateTOC.js" type="text/javascript"></script>
</head>
<body onload="generateTOC(document.getElementById('toc'))">
    <!--begin-logo-->
    <div class=head>
        <p>
            <a href="http://khronos.org/">
                <img alt=Khronos height=60 src="KhronosGroup-3D.png" width=220>
            </a>

        </p>
    </div>
<div class=head> </div>

    <!--end-logo-->
    
    
<h1>KTX File Format Specification</h1>
<h2 class="no-toc">Proposed Final Draft 14 July 2010</h2>
<dl>
  <dt>Editor: 
  <dd> Jacob Str&ouml;m (<a href="http://www.ericsson.com/">Ericsson AB</a>) </dd>
</dl>

    <hr />
    
    <h2 class="no-toc">Abstract</h2>

    
<p> KTX is a format for storing textures for OpenGL and OpenGL ES applications. 
  It is distinguished by the simplicity of the loader required to instantiate 
  a GL texture object from the file contents.</p>

    <h2 class="no-toc">Status of this document</h2>

    
    <!--begin-status-->
    
    <p> This is the proposed final specification document and may be updated, replaced 
      or obsoleted by other documents at any time. Do not cite this document as other 
      than work in progress. </p>
    <!--end-status-->
    
    
<h2 class="no-toc">Table of contents</h2>

    <div id="toc"></div>
	
<h2>File Structure</h2>
<pre class="pseudo-code">Byte[12] identifier
UInt32 endianness
UInt32 glType
UInt32 glTypeSize
UInt32 glFormat
Uint32 glInternalFormat
Uint32 glBaseInternalFormat
UInt32 pixelWidth
UInt32 pixelHeight
UInt32 pixelDepth
UInt32 numberOfArrayElements
UInt32 numberOfFaces
UInt32 numberOfMipmapLevels
UInt32 bytesOfKeyValueData
  
for each keyValuePair that fits in bytesOfKeyValueData
    UInt32   keyAndValueByteSize
    Byte     keyAndValue[keyAndValueByteSize]
    Byte     valuePadding[3 - ((keyAndValueByteSize + 3) % 4)]
end
  
for each mipmap_level in numberOfMipmapLevels<sup>*</sup>
    UInt32 imageSize; 
    for each array_element in numberOfArrayElements<sup>*</sup>
       for each face in numberOfFaces
           for each z_slice in pixelDepth<sup>*</sup>
               for each row or row_of_blocks in pixelHeight<sup>*</sup>
                   for each pixel or block_of_pixels in pixelWidth
                       Byte data[format-specific-number-of-bytes]<sup>**</sup>
                   end
               end
           end
           Byte cubePadding[0-3]
       end
    end
    Byte mipPadding[3 - ((imageSize + 3) % 4)]
end</pre>
<p> * Replace with 1 if this field is 0. </p>
<p>** Uncompressed texture data matches a GL_UNPACK_ALIGNMENT of 4.</p>
<h2>Field Descriptions</h2>
<h3>identifier</h3>
<p>The file identifier is a unique set of bytes that will differentiate the file 
  from other types of files. It consists of 12 bytes, as follows: </p>
<blockquote> 
  <pre>Byte[12] FileIdentifier = {
   0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A
}</pre>
</blockquote>
<p>This can also be expressed using C-style character definitions as: </p>
<blockquote> 
  <pre>Byte[12] FileIdentifier = {
    '&laquo;', 'K', 'T', 'X', ' ', '1', '1', '&raquo;', '\r', '\n', '\x1A', '\n'
}</pre>
</blockquote>
<p>The rationale behind the choice values in the identifier is based on the rationale 
  for the identifier in the PNG specification. This identifier both identifies 
  the file as a KTX file and provides for immediate detection of common file-transfer 
  problems. </p>
<ul>
  <li>Byte [0] is chosen as a non-ASCII value to reduce the probability that a 
    text file may be misrecognized as a KTX file.</li>
  <li>Byte [0] also catches bad file transfers that clear bit 7.</li>
  <li>Bytes [1..6] identify the format, and are the ascii values for the string 
    "KTX 11".</li>
  <li>Byte [7] is for aesthetic balance with byte 1 (they are a matching pair 
    of double-angle quotation marks).</li>
  <li>Bytes [8..9] form a CR-LF sequence which catches bad file transfers that 
    alter newline sequences.</li>
  <li>Byte [10] is a control-Z character, which stops file display under MS-DOS, 
    and further reduces the chance that a text file will be falsely recognised.</li>
  <li>Byte [11] is a final line feed, which checks for the inverse of the CR-LF 
    translation problem.</li>
</ul>
<h3>endianness</h3>
<p> endianness contains the number 0x04030201 written as a 32 bit integer. If 
  the file is little endian then this is represented as the bytes 0x01 0x02 0x03 
  0x04. If the file is big endian then this is represented as the bytes 0x04 0x03 
  0x02 0x01. When reading endianness as a 32 bit integer produces the value 0x04030201 
  then the endianness of the file matches the the endianness of the program that 
  is reading the file and no conversion is necessary. When reading endianness 
  as a 32 bit integer produces the value 0x01020304 then the endianness of the 
  file is opposite the endianness of the program that is reading the file, and 
  in that case the program reading the file must endian convert all header bytes 
  to the endianness of the program (i.e. a little endian program must convert 
  from big endian, and a big endian program must convert to little endian).</p>
<h3>glType</h3>
<p>For compressed textures, glType must equal 0. For non-compressed textures, 
  glType specifies the type argument passed to glTexImage*D, usually one of the 
  values from table 3.2 of the OpenGL 4.0 specification (UNSIGNED_BYTE, UNSIGNED_SHORT_5_6_5, 
  etc.)</p>
<h3>glTypeSize</h3>
<p> glTypeSize specifies the data type size that should be used when 
  endianness conversion is required for the texture data stored in the 
  file. If glType is not 0, this should be the size in bytes corresponding 
  to glType. For texture data which does not depend on platform endianness, 
  including compressed texture data, glTypeSize must equal 1.</p>
<h3>glFormat</h3>
<p>For compressed textures, glFormat must equal 0. For non-compressed textures, 
  glFormat specifies the format argument passed to glTexImage*D, usually one of 
  the values from table 3.3 of the OpenGL 4.0 specification (RGB, RGBA, BGRA, 
  etc.)</p>
<h3>glInternalFormat</h3>
<p> For compressed textures, glInternalFormat must equal the compressed internalformat, 
  usually one of the values from table 3.14 of the OpenGL 4.0 specification. For 
  non-compressed textures, glInternalFormat specifies the internalformat argument 
  passed to glTexImage*D, usually one of the sized internalformats from tables 
  3.12-3.13 of the OpenGL 4.0 specification. The sized format should be chosen 
  to match the bit depth of the data provided. The glInternalFormat is used for 
  loading uncompressed textures in OpenGL and for loading compressed textures 
  in OpenGL and OpenGL ES. It is not usually used for loading uncompressed textures 
  in OpenGL ES as OpenGL ES requires that the internal format be the same value 
  as the format.</p>
<h3>glBaseInternalFormat</h3>
<p> For both compressed and non-compressed textures, glBaseInternalFormat specifies 
  the base internalformat of the texture, usually one of the values from table 
  3.11 of the OpenGL 4.0 specification (RGB, RGBA, ALPHA, etc.). For non-compressed 
  textures, this value will be the same as glFormat and is used as the internalformat 
  when loading into OpenGL ES.</p>
<h3>pixelWidth, pixelHeight, pixelDepth</h3>
<p> The size of the texture image for level 0, in pixels. No rounding to block
  sizes should be applied for block compressed textures.</p>
<p> For 1D textures pixelHeight and pixelDepth must be 0.
  For 2D and cube textures pixelDepth must be 0.</p>
<h3>numberOfArrayElements</h3>
<p>numberOfArrayElements specifies the number of array elements. If the 
  texture is not an array texture, numberOfArrayElements must equal 0.</p>
<h3>numberOfFaces</h3>
<p>numberOfFaces specifies the number of cubemap faces. For cubemaps and 
  cubemap arrays this should be 6. For non cubemaps this should be 1. 
  Cube map faces are stored in the order: +X, -X, +Y, -Y, +Z, -Z.</p>
<h3>numberOfMipmapLevels</h3>
<p>numberOfMipmapLevels must equal 1 for non-mipmapped textures. For 
  mipmapped textures, it equals the number of mipmaps. Mipmaps are stored 
  in order from largest size to smallest size. The first mipmap level is 
  always level 0. A KTX file does not need to contain a complete mipmap 
  pyramid. If numberOfMipmapLevels equals 0, it indicates that a full 
  mipmap pyramid should be generated from level 0 at load time (this is 
  usually not allowed for compressed formats).</p>
<h3>bytesOfKeyValueData</h3>
<p>An arbitrary number of key/value pairs may follow the header. This can be
  used to encode any arbitrary data. The bytesOfKeyValueData field
  indicates the total number of bytes of key/value data including all
  keyAndValueByteSize fields, all keyAndValue fields, and all valuePadding
  fields. The file offset of the first imageSize field is located at the
  file offset of the bytesOfKeyValueData field plus the value of the
  bytesOfKeyValueData field plus 4.</p>
<h3>keyAndValueByteSize</h3>
<p>keyAndValueByteSize is the number of bytes of combined key and value data 
  in one key/value pair following the header. This includes the size of 
  the key, the NUL byte terminating the key, and all the bytes of data in 
  the value. If the value is a UTF8 string it should be NUL terminated and
  the keyAndValueByteSize should include the NUL character (but code that
  reads KTX files must not assume that value fields are NUL terminated).
  keyAndValueByteSize does not include the bytes in valuePadding.</p>
<h3>keyAndValue</h3>
<p>keyAndValue contains 2 separate sections. First it contains a key encoded in 
  UTF8. The key must be terminated by a NUL character (a single 0x00 byte). Keys 
  that begin with the 3 ascii characters 'KTX' or 'ktx' are reserved and must 
  not be used except as described by this spec (this version of the KTX spec defines 
  a single key). Immediately following the NUL character that terminates the key 
  is the Value data. The value may consist of any arbitrary data bytes. Any byte 
  value is allowed. It is encouraged that the value be a NUL terminated UTF8 string, 
  but this is not required. If the Value data is a string of bytes then the NUL 
  termination should be included in the keyAndValueByteSize byte count (but programs 
  that read KTX files must not rely on this).</p>
<h3>valuePadding</h3>
<p>valuePadding contains between 0 and 3 bytes to ensure that the byte following 
  the last byte in valuePadding is at a file offset that is a multiple of 4. This 
  ensures that every keyAndValueByteSize field, and the first imageSize field, 
  is 4 byte aligned. This padding is included in the bytesOfKeyValueData field 
  but not the individual keyAndValueByteSize fields.</p>
<h3>imageSize</h3>
<p>For most textures imageSize is the number of bytes of pixel data in the current 
  LOD level. This includes all z slices, all faces, all rows (or rows of blocks) 
  and all pixels (or blocks) in each row for the mipmap level. It does not include 
  any bytes in mipPadding.</p>
<p> The exception is non-array cubemap textures (any texture where numberOfFaces 
  is 6 and numberOfArrayElements is 0). For these textures imageSize is the number 
  of bytes in each face of the texture for the current LOD level, not including 
  bytes in cubePadding or mipPadding.</p>
<h3>cubePadding</h3>
<p> For non-array cubemap textures (any texture where numberOfFaces is 6 and numberOfArrayElements 
  is 0) cubePadding contains between 0 and 3 bytes to ensure that the data in 
  each face begins at a file offset that is a multiple of 4. In all other cases 
  cubePadding is empty (0 bytes long).</p>
<h3>mipPadding</h3>
<p>Between 0 and 3 bytes to make sure that all imageSize fields are at a
  file offset that is a multiple of 4.</p>
<h2>General comments</h2>
<p>The unpack alignment is 4. I.e. uncompressed pixel data is packed according 
  to the rules described in the OpenGL 1.5 specification for a GL_UNPACK_ALIGNMENTs 
  of 4.</p>
<p> Values listed in tables referred to in the OpenGL 4.0 specification may be 
  supplemented by extensions. The references are given as examples and do not 
  imply that all of those texture types can be loaded in OpenGL ES or earlier 
  versions of OpenGL.</p>
<p>Image data from the KTX file is passed directly to OpenGL therefore the image 
  origin is nominally at the lower left; i.e. with default PixelStore state, texture 
  coordinates and texture transform (if applicable) the first pixel in the data 
  stream will be at s=0, t=0, r=0. Because many popular image file formats use 
  an opposite convention, the first pixel is the upper-right corner, there is 
  plenty of room for confusion. Therefore it is strongly recommended that tools 
  for generating KTX files have an option to choose the texture axis orientation 
  relative to the physical orientation of the source image. At minimum they should 
  provide a choice between top-left and bottom-left as origin for 2D source images, 
  with the positive S axis pointing right.</p>
<p>The required texture axis orientation is often predetermined by, e.g. a DCC 
  tool's or existing application's use of the non-KTX source version of the image. 
  Therefore tools must decide for themselves the appropriate default setting for 
  their orientation option. Where possible, the preferred default is to invert 
  the image data as necessary so that the logical lower-left pixel of the image 
  will be at s=0, t=0.</p>
<p>To allow a KTX file to be shown as intended in an image viewer, it is recommended 
  that KTX tools add the following metadata to the KTX file describing which direction 
  corresponds to the positive S, T, and R axes. </p>
<blockquote> 
  <p>KTXorigin: s[01]t[01]r[01]</p>
</blockquote>
<p>If this metadata is not given, an image viewer should use the GL default of 
  S+ = right, T+ = up, R+ = in which corresponds to a value of s0t0r0.</p>
<h2>An example KTX file:</h2>
<pre class="example">// HEADER
0xAB, 0x4B, 0x54, 0x58, // first four bytes of Byte[12] identifier
0x20, 0x31, 0x31, 0xBB, // next four bytes of Byte[12] identifier
0x0D, 0x0A, 0x1A, 0x0A. // final four bytes of Byte[12] identifier
0x04, 0x03, 0x02, 0x01, // Byte[4] endianess (Big endian in this case)
0x00, 0x00, 0x00, 0x00, // UInt32 glType = 0
0x00, 0x00, 0x00, 0x01, // UInt32 glTypeSize = 1
0x00, 0x00, 0x00, 0x00, // UInt32 glFormat = 0
0x00, 0x00, 0x8D, 0x64, // UInt32 glInternalFormat = GL_ETC1_RGB8_OES
0x00, 0x00, 0x19, 0x07, // UInt32 glBaseInternalFormat = GL_RGB
0x00, 0x00, 0x00, 0x20, // UInt32 pixelWidth = 32
0x00, 0x00, 0x00, 0x20, // UInt32 pixelHeight = 32
0x00, 0x00, 0x00, 0x00, // UInt32 pixelDepth = 0
0x00, 0x00, 0x00, 0x00, // UInt32 numberOfArrayElements = 0
0x00, 0x00, 0x00, 0x01, // UInt32 numberOfFaces = 1
0x00, 0x00, 0x00, 0x01, // UInt32 numberOfMipmapLevels = 1
0x00, 0x00, 0x00, 0x10, // UInt32 bytesOfKeyValueData = 16
// METADATA
0x00, 0x00, 0x00, 0x0A, // UInt32 keyAndValueByteSize = 10
0x61, 0x70, 0x69, 0x00, // UTF8 key:   'api\0'
0x6A, 0x6F, 0x6B, 0x65, // UTF8 v: 'gles2\0'
0x32, 0x00, 0x00, 0x00, // Byte[2] valuePadding (2 bytes)
// TEXTURE DATA
0x00, 0x00, 0x02, 0x00, // UInt32 imageSize = 512 bytes
0xD8, 0xD8, 0xD8, 0xDA, // Byte[512] ETC compressed texture data...
...</pre>
<h2>Acknowledgements</h2>
<p>This specification was produced by the Khronos OpenGL<sup>&reg;</sup> ES Working 
  Group.</p>
<p>Special thanks to: Georg Kolling (Imagination Technology), Acorn Pooley (NVIDIA) 
  and Mark Callow (HI Corporation).</p>
</body>
</html>